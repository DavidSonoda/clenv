from clearml import Task
from clearml.backend_interface.task.populate import CreateAndPopulate
from clenv.cli.queue.queue_manager import QueueManager
from git import Repo
from InquirerPy import prompt
from InquirerPy.validator import PathValidator, EmptyInputValidator
from collections import OrderedDict

import click
import os, json

# Write a subcommand about the task management


@click.group(help="Task management")
def task():
    pass


@task.command(
    help="Execute a task remotely on configured queues. \n\nWhen executing freshly, "
    + "you will be prompted to select a queue to execute the task on. The status info "
    + "of the queues is retrieved from the ClearML server. Corresponding worker infomation, "
    + "including idle workers (The workers that will be able to execute your task immediately) "
    + "and total workers number is displayed. \n\n"
    + "By default, this command will read the run config from the ./.clenv/task_template.json "
    + "file, generated by your last execution with config saved. "
)
@click.option(
    "--new/--no-new",
    "-N",
    help="Freshly execute the task ignoring existing execution configs",
    default=False,
    show_default=True,
    is_flag=True,
)
def exec(new):
    # Give user an interactive prompt to select queue to execute the task from the available queues
    # Solution

    queue_manager = QueueManager()

    available_queues = queue_manager.get_available_queues()

    if len(available_queues) == 0:
        from clenv.cli.config.config_loader import ConfigLoader

        web_server_addr = ConfigLoader().get_config_value("api.web_server")
        click.echo(f"No available queues, please go to {web_server_addr}", err=True)
        return

    # Check if there is existing template
    # Solution
    selected_queue_name = None
    run_config = None
    if os.path.exists("./.clenv/task_template.json") and not new:
        # If there is an existing template, load the template and use it to create a task
        # Solution

        with open("./.clenv/task_template.json", "r") as f:
            run_config = json.load(f)
        # selected_queue_name = run_config["selected_queue"].split("\n")[0]
        # Check if selected_queue is in available_queues by filtering available_queues with name equals to selected_queue
        # Don't use queue manager, filter directly on available_queues
        selected_queue = [
            queue
            for queue in available_queues
            if queue["name"] == run_config["selected_queue"]
        ][0]

        if selected_queue:
            # Check if the selected queue has idle workers
            if not selected_queue["workers"]:
                click.echo("Selected queue has no idle workers", err=True)
                return
        else:
            click.echo("Selected queue is not available", err=True)
            return

        show_config(run_config)
        # Ask user to confirm executing
        result = prompt(
            [
                {
                    "type": "confirm",
                    "message": "Confirm executing the task using the above configuration?",
                    "default": True,
                    "name": "confirm",
                }
            ]
        )
        if not result["confirm"]:
            click.echo("Task execution cancelled")
            return
    else:
        queue_names = [
            f"{queue['name']}\n - idle workers: {[worker['name'] for worker in queue['workers'] if worker['task'] is None]}\n - total workers: {len(queue['workers'])}"
            for queue in available_queues
        ]

        questions = [
            {
                "type": "list",
                "message": "Please choose a queue to execute the task",
                "choices": queue_names,
                "name": "selected_queue",
            },
            {
                "type": "list",
                "message": "Please choose a task type",
                "choices": [
                    "training",
                    "testing",
                    "inference",
                    "data_processing",
                    "application",
                    "monitor",
                    "controller",
                    "optimizer",
                    "service",
                    "qc",
                    "other",
                ],
                "name": "selected_task_type",
            },
            {
                "type": "input",
                "message": "Please enter a task name",
                "name": "task_name",
                "validate": EmptyInputValidator(message="Input cannot be empty"),
            },
            {
                "type": "filepath",
                "message": "Please enter a script path",
                "default": ".",
                "name": "script_path",
                "validate": PathValidator(is_file=True, message="Input is not a file"),
            },
            {
                "type": "confirm",
                "message": "Do you want to save this as a template? If saved, future task creation will be automatically based on this template",
                "name": "save_as_template",
            },
        ]

        asnwers = prompt(questions)
        run_config = make_config(asnwers)

        if asnwers["save_as_template"]:
            # Save the template to the current directory
            # Firstly create a directory named .clenv in the current directory
            # Then create a file named task_template.json in the .clenv directory
            # Then save the answers to the task_template.json file
            # Solution

            os.makedirs(".clenv", exist_ok=True)
            with open(".clenv/task_template.json", "w") as f:
                json.dump(run_config, f, indent=4)

    execute_task(run_config)


# Display the task template using the task template json, the input is a json object
def show_config(task_template):
    # Iterate through all the key value pairs in the task_template
    for key, value in task_template.items():
        desc = key.replace("_", " ").capitalize()
        click.echo(f"{desc}: {value}")


def make_config(raw_template):
    # Iterate through all the key value pairs in the task_template
    # Declare a ordered dictionary to store the pretty template
    run_config = OrderedDict()
    for key, value in raw_template.items():
        if key != "save_as_template":
            val = str(value).split("\n")[0]
            run_config[key] = val
    return run_config


def execute_task(run_config):
    repo = Repo(".")
    # Check if the repo is in detached head state, if so, exit with error
    if repo.head.reference is None:
        click.echo(
            message="The repo is in detached head state, please checkout a branch",
            err=True,
        )

    # Read the git information from current directory
    current_branch = repo.head.reference.name
    remote_url = repo.remotes.origin.url
    project_name = remote_url.split("/")[-1].split(".")[0]

    # Create a task object
    create_populate = CreateAndPopulate(
        project_name=project_name,
        task_name=run_config["task_name"],
        task_type=run_config["selected_task_type"],
        repo=remote_url,
        branch=current_branch,
        # commit=args.commit,
        script=run_config["script_path"],
        # working_directory=args.cwd,
        # packages=args.packages,
        # requirements_file=args.requirements,
        # docker=args.docker,
        # docker_args=args.docker_args,
        # docker_bash_setup_script=bash_setup_script,
        # output_uri=args.output_uri,
        # base_task_id=args.base_task_id,
        # add_task_init_call=not args.skip_task_init,
        # raise_on_missing_entries=True,
        verbose=True,
    )
    create_populate.create_task()

    create_populate.task._set_runtime_properties({"_CLEARML_TASK": True})

    click.echo("New task created id={}".format(create_populate.get_id()))

    Task.enqueue(create_populate.task, queue_name=run_config["selected_queue"])

    click.echo(
        "Task id={} sent for execution on queue {}".format(
            create_populate.get_id(), run_config["selected_queue"]
        )
    )
    click.echo(
        "Execution log at: {}".format(create_populate.task.get_output_log_web_page())
    )
